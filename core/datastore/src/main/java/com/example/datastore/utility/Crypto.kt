package com.example.datastore.utility

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import android.util.Log
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.IvParameterSpec


object Crypto {
    private const val KEY_STORE_ALIAS = "bearer_token_key"
    private const val ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
    private const val BLOCK_MODE = KeyProperties.BLOCK_MODE_GCM
    private const val PADDING = KeyProperties.ENCRYPTION_PADDING_NONE

    private const val GCM_IV_LENGTH = 12 // GCM recommends 12-byte IV (96 bits)
    private const val GCM_TAG_LENGTH = 128 // 128-bit authentication tag

    private const val TRANSFORMATION = "$ALGORITHM/$BLOCK_MODE/$PADDING"

    private val keyStore = KeyStore
        .getInstance("AndroidKeyStore")
        .apply {
            load(null)
        }

    private fun getKey(): SecretKey {
        val existingKey = keyStore.getEntry(KEY_STORE_ALIAS, null) as? KeyStore.SecretKeyEntry
        return existingKey?.secretKey ?: createKey()
    }

    private fun createKey(): SecretKey {
        return KeyGenerator
            .getInstance(ALGORITHM)
            .apply {
                init(
                    KeyGenParameterSpec.Builder(
                        KEY_STORE_ALIAS,
                        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
                    )
                        .setBlockModes(BLOCK_MODE)
                        .setEncryptionPaddings(PADDING)
                        .setKeySize(256)
                        .build()
                )
            }
            .generateKey()
    }


    // Call this function once to delete the old key
    fun deleteKey() {
        if (keyStore.containsAlias(KEY_STORE_ALIAS)) {
            keyStore.deleteEntry(KEY_STORE_ALIAS)
            Log.d("Crypto", "Old key deleted. A new key will be generated.")
        }
    }

    /**Encrypts the given bytes using AES/GCM.
     * Returns a ByteArray containing: [IV (12 bytes)] + [Encrypted Data] + [Auth Tag (16 bytes)]
     */
    fun encrypt(bytes: ByteArray): ByteArray? {
        // Wrap in a try-catch to prevent a crash and handle failures gracefully
        return try {
            val cipher = Cipher.getInstance(TRANSFORMATION)
            cipher.init(
                Cipher.ENCRYPT_MODE,
                getKey() // Initialize cipher WITHOUT providing an IV
            )
            val encryptedDataWithTag = cipher.doFinal(bytes)
            val iv = cipher.iv // Retrieve the IV generated by the cipher
            if (iv == null || iv.size != GCM_IV_LENGTH) {
                Log.e("Crypto", "Encryption failed: IV not generated or incorrect size.")
                return null
            }
            val combinedData = iv + encryptedDataWithTag

            // Use Base64 to encode the combined byte array before logging
            val encodedString = Base64.encodeToString(combinedData, Base64.DEFAULT)

            Log.d("Crypto", "Encryption successful: $encodedString")
            return combinedData
        } catch (e: Exception) {
            Log.e("Crypto", "Encryption failed: " + e.message)
            e.printStackTrace()
            null // Return null on failure
        }
    }

    /**Decrypts the given bytes using AES/GCM.
     * Assumes the input bytes are: [IV (12 bytes)] + [Encrypted Data + Auth Tag]
     * */
    fun decrypt(bytes: ByteArray): ByteArray? {
        // The check is crucial and was correct before you commented it out.
        if (bytes.size < GCM_IV_LENGTH + (GCM_TAG_LENGTH / 8)) {
            Log.e("Crypto", "Input bytes are too short for decryption.")
            return null
        }
        val iv = bytes.copyOfRange(0, GCM_IV_LENGTH)
        val encryptedDataWithTag = bytes.copyOfRange(GCM_IV_LENGTH, bytes.size)
        return try {
            val cipher = Cipher.getInstance(TRANSFORMATION)
            cipher.init(
                Cipher.DECRYPT_MODE,
                getKey(),
                GCMParameterSpec(GCM_TAG_LENGTH, iv)
            )
            val decrypted = cipher.doFinal(encryptedDataWithTag)
            Log.d("Crypto", "Decryption successful: ${String(decrypted)}")
            decrypted
        } catch (e: Exception) {
            Log.e("Crypto", "Decryption failed: " + e.message)
            e.printStackTrace()
            null
        }
    }
}

//
//object Crypto {
//    private const val ALIAS_KEY = "secret"
//    private const val ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
//    private const val BLOCK_MODE = KeyProperties.BLOCK_MODE_CBC
//    private const val PADDING = KeyProperties.ENCRYPTION_PADDING_PKCS7
//    private const val TRANSFORMATION = "$ALGORITHM/$BLOCK_MODE/$PADDING"
//
//    private val cipher = Cipher.getInstance(TRANSFORMATION)
//    private val keyStore = KeyStore
//        .getInstance("AndroidKeyStore")
//        .apply {
//            load(null)
//        }
//
//    private fun getKey(): SecretKey {
//        val existingKey = keyStore.getEntry(ALIAS_KEY, null) as? KeyStore.SecretKeyEntry
//        return existingKey?.secretKey ?: createKey()
//    }
//
//    private fun createKey(): SecretKey {
//        return KeyGenerator
//            .getInstance(ALGORITHM)
//            .apply {
//                init(
//                    KeyGenParameterSpec.Builder(
//                        ALIAS_KEY,
//                        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
//                    )
//                        .setBlockModes(BLOCK_MODE)
//                        .setEncryptionPaddings(PADDING)
//                        .setRandomizedEncryptionRequired(true)
//                        .setUserAuthenticationRequired(false)
//                        .build()
//                )
//            }
//            .generateKey()
//    }
//
//    fun encrypt(bytes: ByteArray): ByteArray {
//        cipher.init(Cipher.ENCRYPT_MODE, getKey())
//        val iv = cipher.iv
//        val encrypted = cipher.doFinal(bytes)
//        return iv + encrypted
//    }
//
//    fun decrypt(bytes:ByteArray):ByteArray{
//        val iv = bytes.copyOfRange(0 , cipher.blockSize)
//        val data = bytes.copyOfRange(cipher.blockSize,bytes.size)
//        cipher.init(Cipher.DECRYPT_MODE, getKey(), IvParameterSpec(iv))
//        return cipher.doFinal(data)
//
//    }
//}